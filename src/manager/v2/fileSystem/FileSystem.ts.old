import { Readable, Writable } from 'stream'
import { RequestContext } from '../../../server/v2/RequestContext'
import { XMLElement } from '../../../helper/XML'
import { LockScope } from '../../../resource/lock/LockScope'
import { LockType } from '../../../resource/lock/LockType'
import { LockKind } from '../../../resource/lock/LockKind'
import { Workflow } from '../../../helper/Workflow'
import { Errors } from '../../../Errors'
import { Lock } from '../../../resource/lock/Lock'
import { Path } from '../Path'
import * as mimeTypes from 'mime-types'
import * as crypto from 'crypto'

export type SimpleCallback = (error ?: Error) => void;
export type ReturnCallback<T> = (error ?: Error, data ?: T) => void;
export type Return2Callback<T1, T2> = (error ?: Error, data1 ?: T1, data2 ?: T2) => void;

export type ResourcePropertyValue = string | XMLElement | XMLElement[]

export interface IContextInfo
{
    context : RequestContext
}

export interface OpenWriteStreamInfo extends IContextInfo
{
    targetSource : boolean
    estimatedSize : number
    mode : OpenWriteStreamMode
}
export interface OpenReadStreamInfo extends IContextInfo
{
    targetSource : boolean
    estimatedSize : number
}
export interface MimeTypeInfo extends IContextInfo
{
    targetSource : boolean
}
export interface SizeInfo extends IContextInfo
{
    targetSource : boolean
}
export interface CreateInfo extends IContextInfo
{
    type : ResourceType
}
export interface CopyInfo extends IContextInfo
{
    depth : number
    overwrite : boolean
}
export interface DeleteInfo extends IContextInfo
{
    depth : number
}
export interface MoveInfo extends IContextInfo
{
    overwrite : boolean
}
export interface ETagInfo extends IContextInfo { }
export interface RenameInfo extends IContextInfo { }
export interface AvailableLocksInfo extends IContextInfo { }
export interface LockManagerInfo extends IContextInfo { }
export interface PropertyManagerInfo extends IContextInfo { }
export interface ReadDirInfo extends IContextInfo { }
export interface CreationDateInfo extends IContextInfo { }
export interface LastModifiedDateInfo extends IContextInfo { }
export interface WebNameInfo extends IContextInfo { }
export interface DisplayNameInfo extends IContextInfo { }
export interface TypeInfo extends IContextInfo { }

export class ResourceType
{
    static File = new ResourceType(true, false)
    static Directory = new ResourceType(false, true)

    static Hybrid = new ResourceType(true, true)
    static NoResource = new ResourceType(false, false)

    constructor(public isFile : boolean, public isDirectory : boolean)
    { }
}

export interface ILockManager
{
    getLocks(callback : ReturnCallback<Lock[]>) : void
    setLock(lock : Lock, callback : SimpleCallback) : void
    removeLock(uuid : string, callback : ReturnCallback<boolean>) : void
    getLock(uuid : string, callback : ReturnCallback<Lock>) : void
    refresh(uuid : string, timeout : number, callback : ReturnCallback<Lock>) : void
}
export class LocalLockManager implements ILockManager
{
    locks : Lock[] = [];

    getLocks(callback : ReturnCallback<Lock[]>) : void
    {
        this.locks = this.locks.filter((lock) => !lock.expired());
        
        callback(null, this.locks);
    }

    setLock(lock : Lock, callback : SimpleCallback) : void
    {
        this.locks.push(lock);
        callback(null);
    }

    removeLock(uuid : string, callback : ReturnCallback<boolean>) : void
    {
        for(let index = 0; index < this.locks.length; ++index)
            if(this.locks[index].uuid === uuid)
            {
                this.locks.splice(index, 1);
                return callback(null, true);
            }
        
        callback(null, false);
    }

    getLock(uuid : string, callback : ReturnCallback<Lock>) : void
    {
        this.locks = this.locks.filter((lock) => !lock.expired());
        
        for(const lock of this.locks)
            if(lock.uuid === uuid)
                return callback(null, lock);
        
        callback();
    }

    refresh(uuid : string, timeout : number, callback : ReturnCallback<Lock>) : void
    {
        this.getLock(uuid, (e, lock) => {
            if(e || !lock)
                return callback(e);
            
            lock.refresh(timeout);
            callback(null, lock);
        })
    }
}

export interface PropertyBag
{
    [name : string] : ResourcePropertyValue
}
export interface IPropertyManager
{
    setProperty(name : string, value : ResourcePropertyValue, callback : SimpleCallback) : void
    getProperty(name : string, callback : ReturnCallback<ResourcePropertyValue>) : void
    removeProperty(name : string, callback : SimpleCallback) : void
    getProperties(callback : ReturnCallback<PropertyBag>, byCopy ?: boolean) : void
}
export class LocalPropertyManager implements IPropertyManager
{
    properties : {
        [name : string] : ResourcePropertyValue
    } = { };

    setProperty(name : string, value : ResourcePropertyValue, callback : SimpleCallback) : void
    {
        this.properties[name] = value;
        callback(null);
    }

    getProperty(name : string, callback : ReturnCallback<ResourcePropertyValue>) : void
    {
        const property = this.properties[name];
        callback(property ? null : Errors.PropertyNotFound, property);
    }

    removeProperty(name : string, callback : SimpleCallback) : void
    {
        delete this.properties[name];
        callback(null);
    }

    getProperties(callback : ReturnCallback<PropertyBag>, byCopy : boolean = false) : void
    {
        callback(null, byCopy ? this.properties : JSON.parse(JSON.stringify(this.properties)));
    }
}

export abstract class StandardMethods
{
    public static standardMove(ctx : RequestContext, subPathFrom : Path, fsFrom : FileSystem, subPathTo : Path, fsTo : FileSystem, callback : ReturnCallback<boolean>) : void
    public static standardMove(ctx : RequestContext, subPathFrom : Path, fsFrom : FileSystem, subPathTo : Path, fsTo : FileSystem, overwrite : boolean, callback : ReturnCallback<boolean>) : void
    public static standardMove(ctx : RequestContext, subPathFrom : Path, fsFrom : FileSystem, subPathTo : Path, fsTo : FileSystem, _overwrite : boolean | ReturnCallback<boolean>, _callback ?: ReturnCallback<boolean>) : void
    {
        const callback = _callback ? _callback : _overwrite as ReturnCallback<boolean>;
        const overwrite = _callback ? _overwrite as boolean : false;

        const go = (fullPathFrom ?: Path) =>
        {
            StandardMethods.standardCopy(ctx, subPathFrom, fsFrom, subPathTo, fsTo, overwrite, -1, (e, overwritten) => {
                if(e)
                    return callback(e, overwritten);
                
                if(fullPathFrom)
                { // subPathFrom.isRoot() === true
                    ctx.server.removeFileSystem(fullPathFrom, (nb) => {
                        callback(null, overwritten);
                    })
                    return;
                }

                fsFrom.delete(ctx, subPathFrom, -1, (e) => callback(e, overwritten));
            })
        }
        
        if(subPathFrom.isRoot())
        {
            fsFrom.getFullPath(ctx, (e, fullPathFrom) => {
                go(fullPathFrom);
            })
        }
        else
            go();
    }



    public static standardCopy(ctx : RequestContext, subPathFrom : Path, fsFrom : FileSystem, subPathTo : Path, fsTo : FileSystem, callback : ReturnCallback<boolean>) : void
    public static standardCopy(ctx : RequestContext, subPathFrom : Path, fsFrom : FileSystem, subPathTo : Path, fsTo : FileSystem, depth : number, callback : ReturnCallback<boolean>) : void
    public static standardCopy(ctx : RequestContext, subPathFrom : Path, fsFrom : FileSystem, subPathTo : Path, fsTo : FileSystem, overwrite : boolean, callback : ReturnCallback<boolean>) : void
    public static standardCopy(ctx : RequestContext, subPathFrom : Path, fsFrom : FileSystem, subPathTo : Path, fsTo : FileSystem, overwrite : boolean, depth : number, callback : ReturnCallback<boolean>) : void
    public static standardCopy(ctx : RequestContext, subPathFrom : Path, fsFrom : FileSystem, subPathTo : Path, fsTo : FileSystem, _overwrite : boolean | number | ReturnCallback<boolean>, _depth ?: number | ReturnCallback<boolean>, _callback ?: ReturnCallback<boolean>) : void
    {
        const overwrite = _overwrite.constructor === Boolean ? _overwrite as boolean : false;
        const depth = _callback ? _depth as number : !_depth ? -1 : _overwrite.constructor === Number ? _overwrite as number : -1;
        const callback = _callback ? _callback : _depth ? _depth as ReturnCallback<boolean> : _overwrite as ReturnCallback<boolean>;

        if(subPathFrom.isRoot())
        {
            fsTo.getFullPath(ctx, subPathTo, (e, fullPathTo) => {
                if(e)
                    return callback(e);
                
                let overwritten = false;
                ctx.server.getResource(ctx, fullPathTo, (e, r) => {
                    if(e)
                        return callback(e);
                    
                    r.type((e, type) => {
                        if(!e)
                            overwritten = true;
                
                        ctx.server.setFileSystem(fullPathTo, fsFrom, (success) => {
                            callback(null, overwritten);
                        })
                    })
                })
            })

            return;
        }

        const go = () =>
        {
            const copyProperties = (callback : SimpleCallback) =>
            {
                fsFrom.propertyManager(ctx, subPathFrom, (e, pmFrom) => {
                    if(e)
                        return callback(e);
                    
                    fsTo.propertyManager(ctx, subPathTo, (e, pmTo) => {
                        if(e)
                            return callback(e);

                        pmFrom.getProperties((e, props) => {
                            if(e)
                                return callback(e);

                            new Workflow()
                                .each(Object.keys(props), (name, cb) => pmTo.setProperty(name, props[name], cb))
                                .error(callback)
                                .done(() => callback())
                        })
                    })
                })
            }

            const reverse1 = (e : Error) => {
                fsTo.delete(ctx, subPathTo, () => callback(e));
            };

            const copyContent = (callback : SimpleCallback) =>
            {
                fsFrom.openReadStream(ctx, subPathFrom, (e, rStream) => {
                    if(e)
                        return reverse1(e);
                    
                    fsTo.openWriteStream(ctx, subPathTo, (e, wStream) => {
                        if(e)
                            return reverse1(e);
                        
                        let _callback = (e) =>
                        {
                            _callback = () => {};
                            callback(e);
                        }

                        rStream.pipe(wStream);
                        rStream.on('error', _callback)
                        wStream.on('error', _callback)
                        wStream.on('finish', () => {
                            _callback(null);
                        })
                    })
                })
            }

            const copyChildren = (callback : SimpleCallback) =>
            {
                fsFrom.readDir(ctx, subPathFrom, false, (e, files) => {
                    if(e)
                        callback(e);
                    
                    const subDepth = depth === -1 ? -1 : Math.max(0, depth - 1);
                    
                    new Workflow()
                        .each(files, (file, cb) => StandardMethods.standardCopy(ctx, subPathFrom.getChildPath(file), fsFrom, subPathTo.getChildPath(file), fsTo, overwrite, subDepth, (e) => cb(e)))
                        .error(callback)
                        .done(() => callback());
                })
            }

            fsFrom.type(ctx, subPathFrom, (e, type) => {
                if(e)
                    return callback(e);
                
                let overwritten = false;

                const startCopy = () =>
                {
                    const fns = [ copyProperties ];

                    if(type.isDirectory && depth !== 0)
                        fns.push(copyChildren);
                    if(type.isFile)
                        fns.push(copyContent);
                    
                    new Workflow()
                        .each(fns, (fn, cb) => fn(cb))
                        .error((e) => callback(e, overwritten))
                        .done(() => callback(null, overwritten));
                }

                fsTo.create(ctx, subPathTo, type, (e) => {
                    if(e === Errors.ResourceAlreadyExists && overwrite)
                    {
                        fsTo.delete(ctx, subPathTo, -1, (e) => {
                            if(e)
                                return callback(e);
                            overwritten = true;

                            fsTo.create(ctx, subPathTo, type, (e) => {
                                if(e)
                                    return callback(e);
                                startCopy();
                            })
                        })
                        return;
                    }
                    else if(e)
                        return callback(e);
                    
                    startCopy();
                })
            })
        }
        
        fsFrom.fastExistCheckEx(ctx, subPathFrom, callback, () => {
            if(!overwrite)
                fsTo.fastExistCheckExReverse(ctx, subPathTo, callback, go);
            else
                go();
        })
    }

    public static standardMimeType(ctx : RequestContext, fs : FileSystem, path : Path, targetSource : boolean, callback : ReturnCallback<string>)
    public static standardMimeType(ctx : RequestContext, fs : FileSystem, path : Path, targetSource : boolean, useWebName : boolean, callback : ReturnCallback<string>)
    public static standardMimeType(ctx : RequestContext, fs : FileSystem, path : Path, targetSource : boolean, defaultMimeType : string, callback : ReturnCallback<string>)
    public static standardMimeType(ctx : RequestContext, fs : FileSystem, path : Path, targetSource : boolean, defaultMimeType : string, useWebName : boolean, callback : ReturnCallback<string>)
    public static standardMimeType(ctx : RequestContext, fs : FileSystem, path : Path, targetSource : boolean, _defaultMimeType : boolean | string | ReturnCallback<string>, _useWebName ?: boolean | ReturnCallback<string>, _callback ?: ReturnCallback<string>)
    {
        let callback;
        let useWebName = false;
        let defaultMimeType = 'application/octet-stream';

        if(_defaultMimeType.constructor === Function)
        {
            callback = _defaultMimeType as ReturnCallback<string>;
        }
        else if(_defaultMimeType.constructor === Boolean)
        {
            callback = _useWebName as ReturnCallback<string>;
            if(_defaultMimeType !== undefined && _defaultMimeType !== null)
                useWebName = _defaultMimeType as boolean;
        }
        else
        {
            callback = _callback as ReturnCallback<string>;
            if(_useWebName !== undefined && _useWebName !== null)
                useWebName = _useWebName as boolean;
            if(_defaultMimeType !== undefined && _defaultMimeType !== null)
                defaultMimeType = _defaultMimeType as string;
        }

        fs.type(ctx, path, (e, type) => {
            if(e)
                return callback(e, null);
            
            if(type.isFile)
            {
                const fn = useWebName ? fs.webName : fs.displayName;
                fn.bind(fs)(ctx, path, (e, name) => {
                    if(e)
                        callback(e, null);
                    else
                    {
                        const mt = mimeTypes.contentType(name);
                        callback(null, mt ? mt as string : defaultMimeType);
                    }
                })
            }
            else
                callback(Errors.NoMimeTypeForAFolder, null);
        })
    }
}

export class ContextualFileSystem implements ISerializableFileSystem
{
    constructor(public fs : FileSystem, public context : RequestContext)
    { }

    resource(path : Path) : Resource
    {
        return new Resource(path, this.fs, this.context);
    }

    delete(path : Path, callback : SimpleCallback) : void
    delete(path : Path, depth : number, callback : SimpleCallback) : void
    delete(path : Path, _depth : any, _callback ?: SimpleCallback) : void
    {
        this.fs.delete(this.context, path, _depth, _callback);
    }
    
    openWriteStream(path : Path, callback : Return2Callback<Writable, boolean>) : void
    openWriteStream(path : Path, estimatedSize : number, callback : Return2Callback<Writable, boolean>) : void
    openWriteStream(path : Path, targetSource : boolean, callback : Return2Callback<Writable, boolean>) : void
    openWriteStream(path : Path, targetSource : boolean, estimatedSize : number, callback : Return2Callback<Writable, boolean>) : void
    openWriteStream(path : Path, mode : OpenWriteStreamMode, callback : Return2Callback<Writable, boolean>) : void
    openWriteStream(path : Path, mode : OpenWriteStreamMode, estimatedSize : number, callback : Return2Callback<Writable, boolean>) : void
    openWriteStream(path : Path, mode : OpenWriteStreamMode, targetSource : boolean, callback : Return2Callback<Writable, boolean>) : void
    openWriteStream(path : Path, mode : OpenWriteStreamMode, targetSource : boolean, estimatedSize : number, callback : Return2Callback<Writable, boolean>) : void
    openWriteStream(path : Path, _mode : any, _targetSource ?: any, _estimatedSize ?: any, _callback ?: Return2Callback<Writable, boolean>) : void
    {
        this.fs.openWriteStream(this.context, path, _mode, _targetSource, _estimatedSize, _callback);
    }

    openReadStream(path : Path, callback : ReturnCallback<Readable>) : void
    openReadStream(path : Path, estimatedSize : number, callback : ReturnCallback<Readable>) : void
    openReadStream(path : Path, targetSource : boolean, callback : ReturnCallback<Readable>) : void
    openReadStream(path : Path, targetSource : boolean, estimatedSize : number, callback : ReturnCallback<Readable>) : void
    openReadStream(path : Path, _targetSource : any, _estimatedSize ?: any, _callback ?: ReturnCallback<Readable>) : void
    {
        this.fs.openReadStream(this.context, path, _targetSource, _estimatedSize, _callback);
    }
    
    copy(pathFrom : Path, pathTo : Path, callback : ReturnCallback<boolean>) : void
    copy(pathFrom : Path, pathTo : Path, depth : number, callback : ReturnCallback<boolean>) : void
    copy(pathFrom : Path, pathTo : Path, overwrite : boolean, callback : ReturnCallback<boolean>) : void
    copy(pathFrom : Path, pathTo : Path, overwrite : boolean, depth : number, callback : ReturnCallback<boolean>) : void
    copy(pathFrom : Path, pathTo : Path, _overwrite : any, _depth ?: any, _callback ?: ReturnCallback<boolean>) : void
    {
        this.fs.copy(this.context, pathFrom, pathTo, _overwrite, _depth, _callback);
    }

    mimeType(path : Path, callback : ReturnCallback<string>) : void
    mimeType(path : Path, targetSource : boolean, callback : ReturnCallback<string>) : void
    mimeType(path : Path, _targetSource : any, _callback ?: ReturnCallback<string>) : void
    {
        this.fs.mimeType(this.context, path, _targetSource, _callback);
    }

    size(path : Path, callback : ReturnCallback<number>) : void
    size(path : Path, targetSource : boolean, callback : ReturnCallback<number>) : void
    size(path : Path, _targetSource : any, _callback ?: ReturnCallback<number>) : void
    {
        this.fs.size(this.context, path, _targetSource, _callback);
    }
    
    addSubTree(rootPath : Path, subTree : SubTree, callback : SimpleCallback)
    addSubTree(rootPath : Path, resourceType : ResourceType, callback : SimpleCallback)
    addSubTree(rootPath : Path, tree : any, callback : SimpleCallback)
    {
        this.fs.size(this.context, rootPath, tree, callback);
    }

    create(path : Path, type : ResourceType, callback : SimpleCallback) : void
    create(path : Path, type : ResourceType, createIntermediates : boolean, callback : SimpleCallback) : void
    create(path : Path, type : ResourceType, _createIntermediates : any, _callback ?: SimpleCallback) : void
    {
        this.fs.create(this.context, path, type, _createIntermediates, _callback);
    }
    etag(path : Path, callback : ReturnCallback<string>) : void
    {
        this.fs.etag(this.context, path, callback);
    }
    move(pathFrom : Path, pathTo : Path, callback : ReturnCallback<boolean>) : void
    move(pathFrom : Path, pathTo : Path, overwrite : boolean, callback : ReturnCallback<boolean>) : void
    move(pathFrom : Path, pathTo : Path, _overwrite : any, _callback ?: ReturnCallback<boolean>) : void
    {
        this.fs.move(this.context, pathFrom, pathTo, _overwrite, _callback);
    }
    rename(pathFrom : Path, newName : string, callback : SimpleCallback) : void
    {
        this.fs.rename(this.context, pathFrom, newName, callback);
    }
    availableLocks(path : Path, callback : ReturnCallback<LockKind[]>) : void
    {
        this.fs.availableLocks(this.context, path, callback);
    }
    lockManager(path : Path, callback : ReturnCallback<ILockManager>) : void
    {
        this.fs.lockManager(this.context, path, callback);
    }
    propertyManager(path : Path, callback : ReturnCallback<IPropertyManager>) : void
    {
        this.fs.propertyManager(this.context, path, callback);
    }
    readDir(path : Path, callback : ReturnCallback<string[]>) : void
    readDir(path : Path, retrieveExternalFiles : boolean, callback : ReturnCallback<string[]>) : void
    readDir(path : Path, _retrieveExternalFiles : any, _callback ?: ReturnCallback<string[]>) : void
    {
        this.fs.readDir(this.context, path, _retrieveExternalFiles, _callback);
    }
    creationDate(path : Path, callback : ReturnCallback<number>) : void
    {
        this.fs.creationDate(this.context, path, callback);
    }
    lastModifiedDate(path : Path, callback : ReturnCallback<number>) : void
    {
        this.fs.lastModifiedDate(this.context, path, callback);
    }
    webName(path : Path, callback : ReturnCallback<string>) : void
    {
        this.fs.webName(this.context, path, callback);
    }
    displayName(path : Path, callback : ReturnCallback<string>) : void
    {
        this.fs.displayName(this.context, path, callback);
    }
    type(path : Path, callback : ReturnCallback<ResourceType>) : void
    {
        this.fs.type(this.context, path, callback);
    }
    
    listDeepLocks(startPath : Path, callback : ReturnCallback<{ [path : string] : Lock[] }>)
    listDeepLocks(startPath : Path, depth : number, callback : ReturnCallback<{ [path : string] : Lock[] }>)
    listDeepLocks(startPath : Path, _depth : any, _callback ?: ReturnCallback<{ [path : string] : Lock[] }>)
    {
        this.fs.listDeepLocks(this.context, startPath, _depth, _callback);
    }
    
    serializer() : FileSystemSerializer
    {
        return this.fs.serializer();
    }
    serialize(callback : (serializedData : any) => void) : void
    {
        this.fs.serialize(callback);
    }
}

export class Resource
{
    constructor(public path : Path, public fs : FileSystem, public context : RequestContext)
    { }

    delete(callback : SimpleCallback) : void
    delete(depth : number, callback : SimpleCallback) : void
    delete(_depth : any, _callback ?: SimpleCallback) : void
    {
        this.fs.delete(this.context, this.path, _depth, _callback);
    }
    
    openWriteStream(callback : Return2Callback<Writable, boolean>) : void
    openWriteStream(estimatedSize : number, callback : Return2Callback<Writable, boolean>) : void
    openWriteStream(targetSource : boolean, callback : Return2Callback<Writable, boolean>) : void
    openWriteStream(targetSource : boolean, estimatedSize : number, callback : Return2Callback<Writable, boolean>) : void
    openWriteStream(mode : OpenWriteStreamMode, callback : Return2Callback<Writable, boolean>) : void
    openWriteStream(mode : OpenWriteStreamMode, estimatedSize : number, callback : Return2Callback<Writable, boolean>) : void
    openWriteStream(mode : OpenWriteStreamMode, targetSource : boolean, callback : Return2Callback<Writable, boolean>) : void
    openWriteStream(mode : OpenWriteStreamMode, targetSource : boolean, estimatedSize : number, callback : Return2Callback<Writable, boolean>) : void
    openWriteStream(_mode : any, _targetSource ?: any, _estimatedSize ?: any, _callback ?: Return2Callback<Writable, boolean>) : void
    {
        this.fs.openWriteStream(this.context, this.path, _mode, _targetSource, _estimatedSize, _callback);
    }

    openReadStream(callback : ReturnCallback<Readable>) : void
    openReadStream(estimatedSize : number, callback : ReturnCallback<Readable>) : void
    openReadStream(targetSource : boolean, callback : ReturnCallback<Readable>) : void
    openReadStream(targetSource : boolean, estimatedSize : number, callback : ReturnCallback<Readable>) : void
    openReadStream(_targetSource : any, _estimatedSize ?: any, _callback ?: ReturnCallback<Readable>) : void
    {
        this.fs.openReadStream(this.context, this.path, _targetSource, _estimatedSize, _callback);
    }
    
    copy(pathTo : Path, callback : ReturnCallback<boolean>) : void
    copy(pathTo : Path, depth : number, callback : ReturnCallback<boolean>) : void
    copy(pathTo : Path, overwrite : boolean, callback : ReturnCallback<boolean>) : void
    copy(pathTo : Path, overwrite : boolean, depth : number, callback : ReturnCallback<boolean>) : void
    copy(pathTo : Path, _overwrite : any, _depth ?: any, _callback ?: ReturnCallback<boolean>) : void
    {
        this.fs.copy(this.context, this.path, pathTo, _overwrite, _depth, _callback);
    }

    mimeType(callback : ReturnCallback<string>) : void
    mimeType(targetSource : boolean, callback : ReturnCallback<string>) : void
    mimeType(_targetSource : any, _callback ?: ReturnCallback<string>) : void
    {
        this.fs.mimeType(this.context, this.path, _targetSource, _callback);
    }

    size(callback : ReturnCallback<number>) : void
    size(targetSource : boolean, callback : ReturnCallback<number>) : void
    size(_targetSource : any, _callback ?: ReturnCallback<number>) : void
    {
        this.fs.size(this.context, this.path, _targetSource, _callback);
    }
    
    addSubTree(subTree : SubTree, callback : SimpleCallback)
    addSubTree(resourceType : ResourceType, callback : SimpleCallback)
    addSubTree(tree : any, callback : SimpleCallback)
    {
        this.fs.addSubTree(this.context, this.path, tree, callback);
    }

    create(type : ResourceType, callback : SimpleCallback) : void
    create(type : ResourceType, createIntermediates : boolean, callback : SimpleCallback) : void
    create(type : ResourceType, _createIntermediates : any, _callback ?: SimpleCallback) : void
    {
        this.fs.create(this.context, this.path, type, _createIntermediates, _callback);
    }
    etag(callback : ReturnCallback<string>) : void
    {
        this.fs.etag(this.context, this.path, callback);
    }
    move(pathTo : Path, callback : ReturnCallback<boolean>) : void
    move(pathTo : Path, overwrite : boolean, callback : ReturnCallback<boolean>) : void
    move(pathTo : Path, _overwrite : any, _callback ?: ReturnCallback<boolean>) : void
    {
        this.fs.move(this.context, this.path, pathTo, _overwrite, _callback);
    }
    rename(newName : string, callback : SimpleCallback) : void
    {
        this.fs.rename(this.context, this.path, newName, callback);
    }
    availableLocks(callback : ReturnCallback<LockKind[]>) : void
    {
        this.fs.availableLocks(this.context, this.path, callback);
    }
    lockManager(callback : ReturnCallback<ILockManager>) : void
    {
        this.fs.lockManager(this.context, this.path, callback);
    }
    propertyManager(callback : ReturnCallback<IPropertyManager>) : void
    {
        this.fs.propertyManager(this.context, this.path, callback);
    }
    readDir(callback : ReturnCallback<string[]>) : void
    readDir(retrieveExternalFiles : boolean, callback : ReturnCallback<string[]>) : void
    readDir(_retrieveExternalFiles : any, _callback ?: ReturnCallback<string[]>) : void
    {
        this.fs.readDir(this.context, this.path, _retrieveExternalFiles, _callback);
    }
    creationDate(callback : ReturnCallback<number>) : void
    {
        this.fs.creationDate(this.context, this.path, callback);
    }
    lastModifiedDate(callback : ReturnCallback<number>) : void
    {
        this.fs.lastModifiedDate(this.context, this.path, callback);
    }
    webName(callback : ReturnCallback<string>) : void
    {
        this.fs.webName(this.context, this.path, callback);
    }
    displayName(callback : ReturnCallback<string>) : void
    {
        this.fs.displayName(this.context, this.path, callback);
    }
    type(callback : ReturnCallback<ResourceType>) : void
    {
        this.fs.type(this.context, this.path, callback);
    }
    
    listDeepLocks(callback : ReturnCallback<{ [path : string] : Lock[] }>)
    listDeepLocks(depth : number, callback : ReturnCallback<{ [path : string] : Lock[] }>)
    listDeepLocks(_depth : any, _callback ?: ReturnCallback<{ [path : string] : Lock[] }>)
    {
        this.fs.listDeepLocks(this.context, this.path, _depth, _callback);
    }
}

export interface ISerializableFileSystem
{
    serializer() : FileSystemSerializer;
    serialize(callback : ReturnCallback<any>) : void
}

export type OpenWriteStreamMode = 'mustCreate' | 'canCreate' | 'mustExist' | 'canCreateIntermediates' | 'mustCreateIntermediates';

export abstract class FileSystem implements ISerializableFileSystem
{
    private __serializer;

    constructor(serializer : FileSystemSerializer)
    {
        this.__serializer = serializer;
    }
    
    serializer() : FileSystemSerializer
    {
        return this.__serializer;
    }

    contextualize(ctx : RequestContext) : ContextualFileSystem
    {
        return new ContextualFileSystem(this, ctx);
    }

    resource(ctx : RequestContext, path : Path) : Resource
    {
        return new Resource(path, this, ctx);
    }
    
    fastExistCheckEx(ctx : RequestContext, path : Path, errorCallback : SimpleCallback, callback : () => void) : void
    {
        if(!this._fastExistCheck)
            return callback();
        
        this._fastExistCheck(ctx, path, (exists) => {
            if(!exists)
                errorCallback(Errors.ResourceNotFound);
            else
                callback();
        });
    }
    fastExistCheckExReverse(ctx : RequestContext, path : Path, errorCallback : SimpleCallback, callback : () => void) : void
    {
        if(!this._fastExistCheck)
            return callback();
        
        this._fastExistCheck(ctx, path, (exists) => {
            if(exists)
                errorCallback(Errors.ResourceAlreadyExists);
            else
                callback();
        });
    }
    protected fastExistCheck(ctx : RequestContext, path : Path, callback : (exists : boolean) => void) : void
    {
        if(!this._fastExistCheck)
            return callback(true);
        
        this._fastExistCheck(ctx, path, (exists) => callback(!!exists));
    }
    protected _fastExistCheck?(ctx : RequestContext, path : Path, callback : (exists : boolean) => void) : void

    create(ctx : RequestContext, path : Path, type : ResourceType, callback : SimpleCallback) : void
    create(ctx : RequestContext, path : Path, type : ResourceType, createIntermediates : boolean, callback : SimpleCallback) : void
    create(ctx : RequestContext, path : Path, type : ResourceType, _createIntermediates : boolean | SimpleCallback, _callback ?: SimpleCallback) : void
    {
        const createIntermediates = _callback ? _createIntermediates as boolean : false;
        const callback = _callback ? _callback : _createIntermediates as SimpleCallback;
        
        const go = () => {
            this._create(path, {
                context: ctx,
                type
            }, callback);
        }

        this.fastExistCheckExReverse(ctx, path, callback, () => {
            this.type(ctx, path.getParent(), (e, type) => {
                if(e === Errors.ResourceNotFound)
                {
                    if(!createIntermediates)
                        return callback(Errors.IntermediateResourceMissing);

                    this.getFullPath(ctx, path, (e, fullPath) => {
                        if(e)
                            return callback(e);
                        
                        fullPath = fullPath.getParent();
                        ctx.getResource(fullPath, (e, r) => {
                            if(e)
                                return callback(e);
                            
                            r.create(ResourceType.Directory, (e) => {
                                if(e && e !== Errors.ResourceAlreadyExists)
                                    return callback(e);
                                
                                go();
                            })
                        })
                    })
                    return;
                }
                if(e)
                    return callback(e);
                
                if(!type.isDirectory)
                    return callback(Errors.WrongParentTypeForCreation);

                go();
            })
        })
    }
    protected abstract _create(path : Path, ctx : CreateInfo, callback : SimpleCallback) : void

    etag(ctx : RequestContext, path : Path, callback : ReturnCallback<string>) : void
    {
        this.fastExistCheckEx(ctx, path, callback, () => {
            if(!this._etag)
                return this.lastModifiedDate(ctx, path, (e, date) => {
                    if(e)
                        return callback(e);
                    callback(null, '"' + crypto.createHash('md5').update(date.toString()).digest('hex') + '"');
                })

            this._etag(path, {
                context: ctx
            }, callback);
        })
    }
    protected _etag?(path : Path, ctx : ETagInfo, callback : ReturnCallback<string>) : void

    delete(ctx : RequestContext, path : Path, callback : SimpleCallback) : void
    delete(ctx : RequestContext, path : Path, depth : number, callback : SimpleCallback) : void
    delete(ctx : RequestContext, path : Path, _depth : number | SimpleCallback, _callback ?: SimpleCallback) : void
    {
        const depth = _callback ? _depth as number : -1;
        const callback = _callback ? _callback : _depth as SimpleCallback;

        this.fastExistCheckEx(ctx, path, callback, () => {
            this._delete(path, {
                context: ctx,
                depth
            }, callback);
        })
    }
    protected abstract _delete(path : Path, ctx : DeleteInfo, callback : SimpleCallback) : void
    
    openWriteStream(ctx : RequestContext, path : Path, callback : Return2Callback<Writable, boolean>) : void
    openWriteStream(ctx : RequestContext, path : Path, estimatedSize : number, callback : Return2Callback<Writable, boolean>) : void
    openWriteStream(ctx : RequestContext, path : Path, targetSource : boolean, callback : Return2Callback<Writable, boolean>) : void
    openWriteStream(ctx : RequestContext, path : Path, targetSource : boolean, estimatedSize : number, callback : Return2Callback<Writable, boolean>) : void
    openWriteStream(ctx : RequestContext, path : Path, mode : OpenWriteStreamMode, callback : Return2Callback<Writable, boolean>) : void
    openWriteStream(ctx : RequestContext, path : Path, mode : OpenWriteStreamMode, estimatedSize : number, callback : Return2Callback<Writable, boolean>) : void
    openWriteStream(ctx : RequestContext, path : Path, mode : OpenWriteStreamMode, targetSource : boolean, callback : Return2Callback<Writable, boolean>) : void
    openWriteStream(ctx : RequestContext, path : Path, mode : OpenWriteStreamMode, targetSource : boolean, estimatedSize : number, callback : Return2Callback<Writable, boolean>) : void
    openWriteStream(ctx : RequestContext, path : Path, _mode : OpenWriteStreamMode | boolean | number | Return2Callback<Writable, boolean>, _targetSource ?: boolean | number | Return2Callback<Writable, boolean>, _estimatedSize ?: number | Return2Callback<Writable, boolean>, _callback ?: Return2Callback<Writable, boolean>) : void
    {
        let targetSource = true;
        for(const obj of [ _mode, _targetSource ])
            if(obj && obj.constructor === Boolean)
                targetSource = obj as boolean;

        let estimatedSize = -1;
        for(const obj of [ _mode, _targetSource, _estimatedSize ])
            if(obj && obj.constructor === Number)
                estimatedSize = obj as number;

        let callback;
        for(const obj of [ _mode, _targetSource, _estimatedSize, _callback ])
            if(obj && obj.constructor === Function)
                callback = obj as Return2Callback<Writable, boolean>;
        
        const mode = _mode && _mode.constructor === String ? _mode as OpenWriteStreamMode : 'mustExist';
        let created = false;
        
        if(!this._openWriteStream)
            return callback(Errors.InvalidOperation);
        
        const go = (callback : Return2Callback<Writable, boolean>) =>
        {
            this._openWriteStream(path, {
                context: ctx,
                estimatedSize,
                targetSource,
                mode
            }, (e, wStream) => callback(e, wStream, created));
        }

        const createAndGo = (intermediates : boolean) =>
        {
            this.create(ctx, path, ResourceType.File, intermediates, (e) => {
                if(e)
                    return callback(e);
                
                created = true;
                go(callback);
            })
        }

        switch(mode)
        {
            case 'mustExist':
                this.fastExistCheckEx(ctx, path, callback, () => go(callback));
                break;
            
            case 'mustCreateIntermediates':
            case 'mustCreate':
                createAndGo(mode === 'mustCreateIntermediates');
                break;
            
            case 'canCreateIntermediates':
            case 'canCreate':
                go((e, wStream) => {
                    if(e === Errors.ResourceNotFound)
                        createAndGo(mode === 'canCreateIntermediates');
                    else
                        callback(e, wStream);
                })
                break;
            
            default:
                callback(Errors.IllegalArguments);
                break;
        }
    }
    protected _openWriteStream?(path : Path, ctx : OpenWriteStreamInfo, callback : ReturnCallback<Writable>) : void
    
    openReadStream(ctx : RequestContext, path : Path, callback : ReturnCallback<Readable>) : void
    openReadStream(ctx : RequestContext, path : Path, estimatedSize : number, callback : ReturnCallback<Readable>) : void
    openReadStream(ctx : RequestContext, path : Path, targetSource : boolean, callback : ReturnCallback<Readable>) : void
    openReadStream(ctx : RequestContext, path : Path, targetSource : boolean, estimatedSize : number, callback : ReturnCallback<Readable>) : void
    openReadStream(ctx : RequestContext, path : Path, _targetSource : boolean | number | ReturnCallback<Readable>, _estimatedSize ?: number | ReturnCallback<Readable>, _callback ?: ReturnCallback<Readable>) : void
    {
        const targetSource = _targetSource.constructor === Boolean ? _targetSource as boolean : true;
        const estimatedSize = _callback ? _estimatedSize as number : _estimatedSize ? _targetSource as number : -1;
        const callback = _callback ? _callback : _estimatedSize ? _estimatedSize as ReturnCallback<Readable> : _targetSource as ReturnCallback<Readable>;
        
        this.fastExistCheckEx(ctx, path, callback, () => {
            if(!this._openReadStream)
                return callback(Errors.InvalidOperation);

            this._openReadStream(path, {
                context: ctx,
                estimatedSize,
                targetSource
            }, callback);
        })
    }
    protected _openReadStream?(path : Path, ctx : OpenReadStreamInfo, callback : ReturnCallback<Readable>) : void

    move(ctx : RequestContext, pathFrom : Path, pathTo : Path, callback : ReturnCallback<boolean>) : void
    move(ctx : RequestContext, pathFrom : Path, pathTo : Path, overwrite : boolean, callback : ReturnCallback<boolean>) : void
    move(ctx : RequestContext, pathFrom : Path, pathTo : Path, _overwrite : boolean | ReturnCallback<boolean>, _callback ?: ReturnCallback<boolean>) : void
    {
        const callback = _callback ? _callback : _overwrite as ReturnCallback<boolean>;
        const overwrite = _callback ? _overwrite as boolean : false;

        const go = () =>
        {
            if(this._move)
            {
                this._move(pathFrom, pathTo, {
                    context: ctx,
                    overwrite
                }, callback);
                return;
            }

            StandardMethods.standardMove(ctx, pathFrom, this, pathTo, this, callback);
        }

        this.fastExistCheckEx(ctx, pathFrom, callback, () => {
            if(!overwrite)
                this.fastExistCheckExReverse(ctx, pathTo, callback, go);
            else
                go();
        })
    }
    protected _move?(pathFrom : Path, pathTo : Path, ctx : MoveInfo, callback : ReturnCallback<boolean>) : void

    copy(ctx : RequestContext, pathFrom : Path, pathTo : Path, callback : ReturnCallback<boolean>) : void
    copy(ctx : RequestContext, pathFrom : Path, pathTo : Path, depth : number, callback : ReturnCallback<boolean>) : void
    copy(ctx : RequestContext, pathFrom : Path, pathTo : Path, overwrite : boolean, callback : ReturnCallback<boolean>) : void
    copy(ctx : RequestContext, pathFrom : Path, pathTo : Path, overwrite : boolean, depth : number, callback : ReturnCallback<boolean>) : void
    copy(ctx : RequestContext, pathFrom : Path, pathTo : Path, _overwrite : boolean | number | ReturnCallback<boolean>, _depth ?: number | ReturnCallback<boolean>, _callback ?: ReturnCallback<boolean>) : void
    {
        const overwrite = _overwrite.constructor === Boolean ? _overwrite as boolean : false;
        const depth = _callback ? _depth as number : !_depth ? -1 : _overwrite.constructor === Number ? _overwrite as number : -1;
        const callback = _callback ? _callback : _depth ? _depth as ReturnCallback<boolean> : _overwrite as ReturnCallback<boolean>;

        if(this._copy)
        {
            const go = () =>
            {
                this._copy(pathFrom, pathTo, {
                    context: ctx,
                    depth,
                    overwrite
                }, callback);
            }
            
            this.fastExistCheckEx(ctx, pathFrom, callback, () => {
                if(!overwrite)
                    this.fastExistCheckExReverse(ctx, pathTo, callback, go);
                else
                    go();
            })
        }
        else
            StandardMethods.standardCopy(ctx, pathFrom, this, pathTo, this, overwrite, depth, callback);
        
    }
    protected _copy?(pathFrom : Path, pathTo : Path, ctx : CopyInfo, callback : ReturnCallback<boolean>) : void

    rename(ctx : RequestContext, pathFrom : Path, newName : string, callback : SimpleCallback) : void
    {
        this.fastExistCheckEx(ctx, pathFrom, callback, () => {
        this.fastExistCheckExReverse(ctx, pathFrom.getParent().getChildPath(newName), callback, () => {
            if(this._rename)
            {
                this._rename(pathFrom, newName, {
                    context: ctx
                }, callback);
                return;
            }

            this.move(ctx, pathFrom, pathFrom.getParent().getChildPath(newName), callback);
        })
        })
    }
    protected _rename?(pathFrom : Path, newName : string, ctx : RenameInfo, callback : SimpleCallback) : void

    mimeType(ctx : RequestContext, path : Path, callback : ReturnCallback<string>) : void
    mimeType(ctx : RequestContext, path : Path, targetSource : boolean, callback : ReturnCallback<string>) : void
    mimeType(ctx : RequestContext, path : Path, _targetSource : boolean | ReturnCallback<string>, _callback ?: ReturnCallback<string>) : void
    {
        const targetSource = _callback ? _targetSource as boolean : true;
        const callback = _callback ? _callback : _targetSource as ReturnCallback<string>;

        this.fastExistCheckEx(ctx, path, callback, () => {
            if(this._mimeType)
            {
                this._mimeType(path, {
                    context: ctx,
                    targetSource
                }, callback);
                return;
            }

            StandardMethods.standardMimeType(ctx, this, path, targetSource, callback);
        })
    }
    protected _mimeType?(path : Path, ctx : MimeTypeInfo, callback : ReturnCallback<string>) : void

    size(ctx : RequestContext, path : Path, callback : ReturnCallback<number>) : void
    size(ctx : RequestContext, path : Path, targetSource : boolean, callback : ReturnCallback<number>) : void
    size(ctx : RequestContext, path : Path, _targetSource : boolean | ReturnCallback<number>, _callback ?: ReturnCallback<number>) : void
    {
        const targetSource = _callback ? _targetSource as boolean : true;
        const callback = _callback ? _callback : _targetSource as ReturnCallback<number>;

        this.fastExistCheckEx(ctx, path, callback, () => {
            if(!this._size)
                return callback(Errors.InvalidOperation);

            this._size(path, {
                context: ctx,
                targetSource
            }, callback);
        })
    }
    protected _size?(path : Path, ctx : SizeInfo, callback : ReturnCallback<number>) : void

    availableLocks(ctx : RequestContext, path : Path, callback : ReturnCallback<LockKind[]>) : void
    {
        this.fastExistCheckEx(ctx, path, callback, () => {
            if(!this._availableLocks)
                return callback(null, [
                    new LockKind(LockScope.Exclusive, LockType.Write),
                    new LockKind(LockScope.Shared, LockType.Write)
                ]);

            this._availableLocks(path, {
                context: ctx
            }, callback);
        })
    }
    protected _availableLocks?(path : Path, ctx : AvailableLocksInfo, callback : ReturnCallback<LockKind[]>) : void

    lockManager(ctx : RequestContext, path : Path, callback : ReturnCallback<ILockManager>) : void
    {
        this.fastExistCheckEx(ctx, path, callback, () => {
            this._lockManager(path, {
                context: ctx
            }, callback);
        })
    }
    protected abstract _lockManager(path : Path, ctx : LockManagerInfo, callback : ReturnCallback<ILockManager>) : void

    propertyManager(ctx : RequestContext, path : Path, callback : ReturnCallback<IPropertyManager>) : void
    {
        this.fastExistCheckEx(ctx, path, callback, () => {
            this._propertyManager(path, {
                context: ctx
            }, callback);
        })
    }
    protected abstract _propertyManager(path : Path, ctx : PropertyManagerInfo, callback : ReturnCallback<IPropertyManager>) : void

    readDir(ctx : RequestContext, path : Path, callback : ReturnCallback<string[]>) : void
    readDir(ctx : RequestContext, path : Path, retrieveExternalFiles : boolean, callback : ReturnCallback<string[]>) : void
    readDir(ctx : RequestContext, path : Path, _retrieveExternalFiles : boolean | ReturnCallback<string[]>, _callback ?: ReturnCallback<string[]>) : void
    {
        const retrieveExternalFiles = _callback ? _retrieveExternalFiles as boolean : false;
        const callback = _callback ? _callback : _retrieveExternalFiles as ReturnCallback<string[]>;

        this.fastExistCheckEx(ctx, path, callback, () => {
            const next = (base : string[]) => {
                if(!this._readDir)
                    return callback(null, base);
                
                this._readDir(path, {
                    context: ctx
                }, (e, paths) => {
                    if(e)
                        return callback(e);
                    
                    if(paths.length === 0)
                        return callback(null, base);
                    
                    if(paths[0].constructor === String)
                        base = base.concat(paths as string[]);
                    else
                        base = base.concat((paths as Path[]).map((p) => p.fileName()));
                    
                    callback(null, base);
                });
            }

            if(!retrieveExternalFiles)
                return next([]);

            this.getFullPath(ctx, (e, thisFullPath) => {
                if(e)
                    return callback(e);
                
                ctx.server.getChildFileSystems(thisFullPath.getChildPath(path), (fss) => {
                    next(fss.map((f) => f.path.fileName()));
                })
            })
        })
    }
    protected _readDir?(path : Path, ctx : ReadDirInfo, callback : ReturnCallback<string[] | Path[]>) : void

    creationDate(ctx : RequestContext, path : Path, callback : ReturnCallback<number>) : void
    {
        this.fastExistCheckEx(ctx, path, callback, () => {
            this._creationDate(path, {
                context: ctx
            }, callback);
        })
    }
    protected abstract _creationDate(path : Path, ctx : CreationDateInfo, callback : ReturnCallback<number>) : void

    lastModifiedDate(ctx : RequestContext, path : Path, callback : ReturnCallback<number>) : void
    {
        this.fastExistCheckEx(ctx, path, callback, () => {
            this._lastModifiedDate(path, {
                context: ctx
            }, callback);
        })
    }
    protected abstract _lastModifiedDate(path : Path, ctx : LastModifiedDateInfo, callback : ReturnCallback<number>) : void

    webName(ctx : RequestContext, path : Path, callback : ReturnCallback<string>) : void
    {
        this.fastExistCheckEx(ctx, path, callback, () => {
            if(path.isRoot())
                this.getFullPath(ctx, (e, path) => callback(e, e ? null : path.fileName()));
            else
                callback(null, path.fileName());
        })
    }

    displayName(ctx : RequestContext, path : Path, callback : ReturnCallback<string>) : void
    {
        this.fastExistCheckEx(ctx, path, callback, () => {
            if(!this._displayName)
                return this.webName(ctx, path, callback);
            
            this._displayName(path, {
                context: ctx
            }, callback);
        })
    }
    protected _displayName?(path : Path, ctx : DisplayNameInfo, callback : ReturnCallback<string>) : void

    type(ctx : RequestContext, path : Path, callback : ReturnCallback<ResourceType>) : void
    {
        this.fastExistCheckEx(ctx, path, callback, () => {
            this._type(path, {
                context: ctx
            }, callback);
        })
    }
    protected abstract _type(path : Path, ctx : TypeInfo, callback : ReturnCallback<ResourceType>) : void

    addSubTree(ctx : RequestContext, subTree : SubTree, callback : SimpleCallback)
    addSubTree(ctx : RequestContext, resourceType : ResourceType, callback : SimpleCallback)
    addSubTree(ctx : RequestContext, rootPath : Path, subTree : SubTree, callback : SimpleCallback)
    addSubTree(ctx : RequestContext, rootPath : Path, resourceType : ResourceType, callback : SimpleCallback)
    addSubTree(ctx : RequestContext, _rootPath : Path | SubTree | ResourceType | SimpleCallback, _tree : SubTree | ResourceType | SimpleCallback, _callback ?: SimpleCallback)
    {
        const callback = _callback ? _callback : _tree as SimpleCallback;
        const tree = _callback ? _tree as SubTree | ResourceType : _rootPath as SubTree | ResourceType;
        const rootPath = _callback ? _rootPath as Path : new Path('/');

        if(tree.constructor === ResourceType)
        {
            this.create(ctx, rootPath, tree as ResourceType, callback);
        }
        else
        {
            new Workflow()
                .each(Object.keys(tree), (name, cb) => {
                    const value = tree[name];
                    if(value.constructor === ResourceType)
                        this.addSubTree(ctx, rootPath.getChildPath(name), value, cb)
                    else
                        this.addSubTree(ctx, rootPath.getChildPath(name), ResourceType.Directory, (e) => {
                            if(e)
                                return cb(e);
                                
                            this.addSubTree(ctx, rootPath.getChildPath(name), value, cb);
                        })
                })
                .error(callback)
                .done(() => callback());
        }
    }

    listDeepLocks(ctx : RequestContext, startPath : Path, callback : ReturnCallback<{ [path : string] : Lock[] }>)
    listDeepLocks(ctx : RequestContext, startPath : Path, depth : number, callback : ReturnCallback<{ [path : string] : Lock[] }>)
    listDeepLocks(ctx : RequestContext, startPath : Path, _depth : number | ReturnCallback<{ [path : string] : Lock[] }>, _callback ?: ReturnCallback<{ [path : string] : Lock[] }>)
    {
        const depth = _callback ? _depth as number : 0;
        const callback = _callback ? _callback : _depth as ReturnCallback<{ [path : string] : Lock[] }>;

        this.lockManager(ctx, startPath, (e, lm) => {
            if(e)
                return callback(e);
            
            lm.getLocks((e, locks) => {
                if(e)
                    return callback(e);
                
                if(depth != -1)
                    locks = locks.filter((f) => f.depth === -1 || f.depth >= depth);
                
                const go = (fs : FileSystem, parentPath : Path) =>
                {
                    const destDepth = depth === -1 ? -1 : depth + 1;
                    fs.listDeepLocks(ctx, parentPath, destDepth, (e, pLocks) => {
                        if(e)
                            return callback(e);
                        
                        if(locks && locks.length > 0)
                            pLocks[startPath.toString()] = locks;
                        callback(null, pLocks);
                    })
                }

                if(!startPath.isRoot())
                    return go(this, startPath.getParent());
                
                this.getFullPath(ctx, (e, fsPath) => {
                    if(e)
                        return callback(e);
                    
                    if(fsPath.isRoot())
                    {
                        const result = {};
                        if(locks && locks.length > 0)
                            result[startPath.toString()] = locks;
                        return callback(null, result);
                    }
                    
                    ctx.server.getFileSystem(fsPath.getParent(), (fs, _, subPath) => {
                        go(fs, subPath);
                    })
                })
            })
        })
    }

    getFullPath(ctx : RequestContext, callback : ReturnCallback<Path>)
    getFullPath(ctx : RequestContext, path : Path, callback : ReturnCallback<Path>)
    getFullPath(ctx : RequestContext, _path : Path | ReturnCallback<Path>, _callback ?: ReturnCallback<Path>)
    {
        const path = _callback ? _path as Path : undefined;
        const callback = _callback ? _callback : _path as ReturnCallback<Path>;

        ctx.server.getFileSystemPath(this, (fsPath) => {
            callback(null, path ? fsPath.getChildPath(path) : fsPath);
        })
    }

    serialize(callback : ReturnCallback<any>) : void
    {
        this.serializer().serialize(this, callback);
    }
}

export interface SubTree
{
    [name : string] : ResourceType | SubTree
}

export interface FileSystemSerializer
{
    uid() : string;
    serialize(fs : FileSystem, callback : ReturnCallback<any>) : void;
    unserialize(serializedData : any, callback : ReturnCallback<FileSystem>) : void;
}

export interface SerializedData
{
    [path : string] : {
        serializer : string
        data : any
    }
}
export interface UnserializedData
{
    [path : string] : FileSystem
}
export function serialize(fileSystems : UnserializedData, callback : ReturnCallback<SerializedData>)
{
    const result : SerializedData = {};
    new Workflow()
        .each(Object.keys(fileSystems), (path, cb) => {
            const fs = fileSystems[path];
            const serializer = fs.serializer();
            serializer.serialize(fs, (e, data) => {
                if(!e)
                    result[path] = {
                        serializer: serializer.uid(),
                        data
                    };
                cb(e)
            });
        })
        .error(callback)
        .done(() => callback(null, result));
}

export function unserialize(serializedData : SerializedData, serializers : FileSystemSerializer[], callback : ReturnCallback<UnserializedData>)
{
    const result : UnserializedData = {};
    new Workflow()
        .each(Object.keys(serializedData), (path, cb) => {
            const sd = serializedData[path];
            let serializer : FileSystemSerializer = null;
            for(const s of serializers)
                if(s.uid() === sd.serializer)
                {
                    serializer = s;
                    break;
                }
            
            if(!serializer)
                return cb(Errors.SerializerNotFound)
            
            serializer.unserialize(sd.data, (e, fs) => {
                if(!e)
                    result[path] = fs;
                callback(e);
            })
        })
        .error(callback)
        .done(() => callback(null, result));
}
